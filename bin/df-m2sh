#!/usr/bin/env sbcl --script

;; Load an RC if we can find it
(let ((rc (probe-file #P"~/.sbclrc")))
  (when rc (load rc)))

;; Load up
(ql:quickload :fdog)
(use-package :fdog-models)
(use-package :fdog-m2sh)

;; Shut up the logger
(log5:stop-all-senders)

;; Script constants
(defvar *self* "df-m2sh")
(defvar *commands* ())

;; Command definition helpers
(defmacro defcommand (name args &body body)
  "Create a function named m2sh-cmd-`name' and add
an entry to the `*commands*' table"
  (let* ((title name)
        (prefix "m2sh-cmd-")
        (cmd-name (intern (string-upcase (concatenate 'string prefix (symbol-name title))))))

    (pushnew `(,title . ,cmd-name) *commands* :test #'(lambda (a b) (and (eql (car a) (car b))
                                                                         (eql (cdr a) (cdr b)))))
    `(defun ,cmd-name ,args
       ,@body)))

(defmacro defcommand! (name args &body body)
  "Create a function that first initializes the databases before executing."
  (let* ((body-val body)
         (doc (and (typep (car body-val) 'string)
                   (car body-val)))
         (g!doc (gensym "doc")))
  `(defcommand ,name ,args
     ,@(if doc (list doc) (values))
     (unless (fdog-models:connected-p) (fdog:init))
     ,@(if doc (rest body) body))))


(defun get-command (name &optional (what :both))
  (let ((cmd (assoc name *commands* :test #'string-equal)))
    (and cmd
         (ecase what
           (:both cmd)
           (:name (car cmd))
           (:function (cdr cmd))))))

(defun call-command (name &optional args)
  (apply (get-command name :function) args))

(defun command-p (name)
  (get-command name))

;; Commands
(defcommand help (&optional command &rest args)
  "help [command]
General help functionality. Give a command for help with a specific thing"
  (let ((cmd (get-command command)))
    (unless cmd
      (usage :message (if command (format nil "Unknown command: ~A" command))
             :exit (if command 2 0)))

    (format t "Help for: ~A~%" (car cmd))
    (format t "  :~A~%" (documentation (cdr cmd) 'function))))

(defcommand! hosts (&optional server-name)
  "hosts <server-name>
Lists the hosts for the given `server-name'"
  (let (hosts
        (server (car (servers :name server-name))))
    (cond ((not server-name)
             (call-command 'help '(hosts)))
          ((not server)
             (format t "No servers found named: '~A'~%" server-name))
          (t
             (format t "Hosts in server named '~A'~%" server-name)
             (format t "--------~%")
             (dolist (host (server-hosts server) hosts)
               (push host hosts)
               (format t "  ~A   ~A~%" (mongrel2-host-id host)
                                     (mongrel2-host-name host)))))))

(defcommand! servers (&key uuid host name)
  "servers [:uuid <uuid> [:host <host>] [:name <name>]]
List the available servers"
  (format t "Servers matching: (:uuid ~A) (:host ~A) (:name ~A)~%" uuid host name)
  (format t "--------~%")
  (let ((servers (servers :uuid uuid :host host :name name)))
    (dolist (server servers servers)
      (format t "  ~A   ~A   ~A~%" (mongrel2-server-name server)
                             (mongrel2-server-default-host server)
                             (mongrel2-server-uuid server)))))

(defcommand! routes (server-name &key host-name host-id)
  "routes <server-name> [:host-name <host-name> :host-id <host-id>]
List the routes for the server named by `server-name' belonging to host named by `host-name' and/or `host-id'"
  (format t "Unimplemented :(~%"))

;; Helers
(defun usage (&key exit (message "Usage information"))
  (when message (format t "~A~%" message))
  (format t "Usage: ~A command [command-options]~%" *self*)
  (format t "Commands:~%")
  (dolist (command *commands*)
    (format t "  ~A~%" (car command)))
  (when exit (quit :unix-status exit)))

;; Aaand go
(labels ((keyword-or-string (arg) (cond ((eql (char arg 0) #\:) (read-from-string arg))
                                        (t arg)))
         (run (&key root self argv)
         (when self (setf *self* self))
         (unless (car argv)
           (usage :exit 1 :message "Invalid usage"))

         (destructuring-bind (command &rest args) argv
           (if (command-p command)
               (call-command command (mapcar #'keyword-or-string args))
             (usage :exit 1 :message (format nil "Unknown command `~A'" command))))

         (quit :unix-status 0)))
  (run
   :root (merge-pathnames ".." (make-pathname :directory (pathname-directory *load-pathname*)))
   :self (make-pathname :directory `(:relative ,(car (last (pathname-directory *load-pathname*))))
                  :name (pathname-name *load-pathname*))
   :argv (rest sb-ext:*posix-argv*)))
